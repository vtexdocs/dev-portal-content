---
title: "Dynamic Content"
---

Dynamic Content is a feature that gives more flexibility to customize the store. This feature enables server-side data-fetching on pages like Homepage and Landing Pages (LP) using FastStore and the headless CMS (hCMS). The data is fetched and can be used in sections. Thus, enhances performance, as well as aspects such as SEO for these pages.

> âš ï¸ Dynamic Content is natively included for stores with the 3.x. `@faststore/core` package version.

Previously, by using sections, it was already possible to make client-side data fetching and create custom markups that could be used as sections for all kinds of pages. Also, with the support of [API Extension](https://developers.vtex.com/docs/guides/faststore/api-extensions-overview), it is possible to fetch server-side data that are injected into Product Listing pages (PLPs) and Product Details Pages (PDPs) using hooks like [usePDP() or usePLP()](https://developers.vtex.com/docs/guides/faststore/api-extensions-consuming-api-extensions).

With that in mind, the Dynamic Content feature is restricted to be used only on the Homepage and Landing Pages using the `useDynamicContent()` hook.

The other kinds of pages are very attached to Collections (PLPs), and Product (PDPs), and the server-side data fetching is already available using API Extensions in these pages. See the [API Extension documentation](https://developers.vtex.com/docs/guides/faststore/api-extensions-overview) if you would like to fetch data on these pages.

## Creating Dynamic Contents

### Mapping page and server-side data-fetching function

Create a `src/dynamicContent/index.ts` file. This file will map the homepage or the landing page slug to a respective data fetch function, which will fetch, handle, and return the desired server-side data.

```ts src/dynamicContent/index.ts
// map the slug to correspondent data-fetching functions
const dynamicContent = {
  home: fetchDataHomepage,
  "my-landing-page": fetchDataMyLandingPage,
};

export default dynamicContent;
```

Note that this file must export the `dynamicContent` object as default.

#### Homepage

The homepage is a singleton page, then it is unique, and for the dynamic content feature, this page is mapped using the key `home`. In that way, you don't need to use hCMS for mapping this page. The value of the home key is a data-fetching function that will be used to return the data, and is going to be explored in the data-fetching section below in this article.

#### Landing Page (LP)

The Landing Page is not a singleton and can represent different pages, so to identify the landing page, the slug from the hCMS SEO Path input from the settings tab is used. In the example below, the value `/my-landing-page`.

![Landing Page Settings Seo Path](https://vtexhelp.vtexassets.com/assets/docs/src/lpseopath___beab493e9781d1b1b8b0cdb821d9d41b.png)

Note that this slug is used as the key in the dynamicContent object, without the initial `/`.

### Server-side data fetching function

Basically, there are two ways of using data fetching functions for Dynamic Content. In the first approach, the Fetch API or any HTTP request lib can directly fetch the data (axios, fetch, etc.). In the second, we leverage the existing API Extension feature to fetch the data.

#### Data fetching using Fetch API or any request library.

The data fetching function will fetch, handle, and return the desired data. In the example below, note that it's possible to make a single request as the `fetchDataMyLandingPage()` method or even use the `Promise.all()` function to parallelize all the requests as the `fetchDataHomepage()` method does.

```ts src/dynamicContent/index.ts
// Using fetch API
async function fetchDataMyLandingPage() {
  const response = await fetch("my-api/my-landing-page-endpoint");
  const data = await response.json();
  return {
    data,
  };
}

// Using fetch API with Promise.all
async function fetchDataHomepage() {
  try {
    const [apiData1, apiData2] = await Promise.all([
      fetch("my-api/endpoint-1").then((response) => response.json()),
      fetch("my-api/endpoint-2").then((response) => response.json()),
    ]);

    return {
      data: {
        apiData1,
        apiData2,
      },
    };
  } catch (error) {
    console.error("Error fetching data from APIs:", error);
    return {
      data: null,
      error: "Error fetching data from APIs",
    };
  }
}

// map the slug to correspondent data-fetching functions
const dynamicContent = {
  home: fetchDataHomepage,
  "my-landing-page": fetchDataMyLandingPage,
};

export default dynamicContent;
```

#### Data Fetching using API Extensions feature.

In this example below, the [API Extension](https://developers.vtex.com/docs/guides/faststore/api-extensions-overview) will be used to create two new third-party queries, these queries will be resolved using resolvers that will fetch data from third-party APIs. Finally, the dynamic content will execute the queries to fetch and return data.

Create the `src/graphql/thirdParty/typeDefs/extra.graphql` file, with the following type definitions:

```graphql src/graphql/thirdParty/typeDefs/extra.graphql
type Rating {
  rate: String
  count: Int
}

type ProductsExtraData {
  id: Int
  title: String
  price: Float
  description: String
  category: String
  image: String
  rating: Rating
}

type ExtraData {
  """
  Data customizing ExtraData
  """
  data: [ProductsExtraData]
  customFieldFromRoot: String
  customField: String
}

type NamedExtraData {
  """
  Data customizing NamedExtraData
  """
  data: String!
}

type Query {
  extraData: ExtraData
  namedExtraData(name: String!): NamedExtraData
}
```

Then, create the corresponding resolvers in the `src/graphql/thirdParty/resolvers/query.ts` file:

```ts src/graphql/thirdParty/resolvers/query.ts
export type ProductsExtraData = {
  id: number;
  title: string;
  price: number;
  description: string;
  category: string;
  image: string;
  rating: {
    rate: string;
    count: number;
  };
};

export type ExtraDataRoot = {
  data?: ProductsExtraData[];
};

async function getProductsFromThirdPartyApi() {
  const result = await fetch("https://fakestoreapi.com/products");
  const json = result.json();
  return json;
}

export const Query = {
  extraData: async (): Promise<{ data: ProductsExtraData[] }> => {
    const products: ProductsExtraData[] = await getProductsFromThirdPartyApi();

    return {
      data: products,
    };
  },
  namedExtraData: (_: unknown, { name }: { name: string }) => {
    return {
      data: `Named extra data: ${name}`,
    };
  },
};
```

Also, the `src/graphql/thirdParty/resolvers/extraData.ts` file with its field resolvers:

```ts src/graphql/thirdParty/resolvers/extraData.ts
import { ExtraDataRoot } from "./query";

export const ExtraData = {
  data: (root: ExtraDataRoot) => root.data,
  customFieldFromRoot: (root: ExtraDataRoot) => root?.data?.[0]?.image ?? "",
  customField: async (_: ExtraDataRoot) => {
    const res = await fetch(
      "https://fakestoreapi.com/products/category/jewelery"
    );
    const customField = await res.json();
    return (customField?.[0]?.title as string) ?? "";
  },
};
```

Finally, include these resolvers in the `src/graphql/thirdParty/resolvers/index.ts` file:

```ts src/graphql/thirdParty/resolvers/index.ts
import { ExtraData } from "./extraData";
import { Query } from "./query";

const resolvers = {
  ExtraData,
  Query,
};

export default resolvers;
```

With these two new queries created as API Extensions, they are now available to be executed in the `src/dynamicContent/index.ts` file, so use the gql function to parse the query

```ts src/dynamicContent/index.ts
import { gql } from "@faststore/core/api";

// 2nd approach - Using API Extensions
// creates a query to fetch the data from API Extensions
const query = gql(`
    query ServerDynamicContent($name: String!){
      extraData {
        data {
          title
          rating {
            rate
            count
          }
        }
        customField
        customFieldFromRoot
      }
      namedExtraData(name: $name) {
        data
      }
    }
`);

// fetches the data using execute function
async function fetchDataMyLandingPage() {
  // data fetching not implemented yet
}

// map the slug to correspondent data-fetching functions
const dynamicContent = {
  "my-landing-page": fetchDataMyLandingPage,
};

export default dynamicContent;
```

With the query created, run the following command:

```sh
yarn dev
```

Now, ensure the GraphQL schema, types, and optimizations will be successfully generated as we can see in the image below:

![GraphQL successfully generated](https://vtexhelp.vtexassets.com/assets/docs/src/graphqlsuccess___d76e7099f3ccf089215101dce9b9cb46.png)

Back to the code, now it's possible to execute the query and leverage the generated types by using the execute method from from the `@faststore/core/experimental` package.

```ts src/dynamicContent/index.ts
import {
  ServerDynamicContentQuery,
  ServerDynamicContentQueryVariables,
  gql,
} from "@faststore/core/api";
import { execute_unstable as execute } from "@faststore/core/experimental/server";

// 2nd approach - Using API Extensions
// creates a query to fetch the data from API Extensions
const query = gql(`
    query ServerDynamicContent($name: String!){
      extraData {
        data {
          title
          rating {
            rate
            count
          }
        }
        customField
        customFieldFromRoot
      }
      namedExtraData(name: $name) {
        data
      }
    }
`);

// fetches the data using execute function
async function fetchDataMyLandingPage() {
  const dynamicContentResult = await execute<
    ServerDynamicContentQueryVariables,
    ServerDynamicContentQuery
  >({
    variables: {
      name: "Variables passed to query - Dynamic Content Feature",
    },
    operation: query,
  });
  return {
    data: dynamicContentResult.data,
  };
}

// map the slug to correspondent functions
const dynamicContent = {
  "my-landing-page": fetchDataMyLandingPage,
};

export default dynamicContent;
```

#### Returning the data Object

For both approaches, Data fetching using Fetch API or Data Fetching using API Extensions feature, the data-fetching function must return an object with data as root key, in the following format:

```ts
return {
  data: {
    // data fetched
  },
};
```

The data object can contain other objects inside:

```ts
return {
  data: {
    key1: result1,
    key2: result2,
  },
};
```

## Consuming Dynamic Content in Sections.

In this guide, learn how to consume dynamic content in custom sections and overridable sections.

FastStore exposes the data that comes from Dynamic Content inside a page provider, and you can use the `useDynamicContent()` hook to access them:

### Consuming Dynamic Content in custom sections

To illustrate how to consume Dynamic Content from custom sections, we'll use the `CallToAction` section as an example from the [Creating a new section guide](https://developers.vtex.com/docs/guides/faststore/building-sections-creating-a-new-section) inside a Landing page. So, ensure to have followed this guide mentioned before to have a new section in hCMS.

With the section added, run the following command to sync with hCMS:

```sh
yarn cms-sync
```

Remember to add this section to the Landing Page to see the dynamic content.

![Landing page sections](https://vtexhelp.vtexassets.com/assets/docs/src/lpsections___8e640c239e0bc198ee6b47479f57c87d.png)

Once you have the `CallToAction` section, create the `src/components/sections/CallToAction.tsx` file as the example below. Note the `useDynamicContent()` hook available to retrieve the dynamic content. It's also possible to add the data type as generics. In this example, the `ServerDynamicContentQuery` is used as generics representing the data object type, that comes from the API Extension approach shown above.

```tsx src/components/sections/CallToAction.tsx
import { useDynamicContent } from "@faststore/core";
import { ServerDynamicContentQuery } from "@faststore/core/api";

export interface CallToActionProps {
  title: string;
  link: {
    text: string;
    url: string;
  };
}

export default function CallToAction(props: CallToActionProps) {
  const context = useDynamicContent<ServerDynamicContentQuery>();
  console.log("ðŸš€ ~ CallToAction context:", context);
  return (
    <section>
      <h2>{`${props.title} ${context?.data?.namedExtraData?.data}`}</h2>
    </section>
  );
}
```

Remember to import the new Section in the `src/components/index.tsx` file:

```tsx src/components/index.tsx
import CallToAction from "./sections/CallToAction";

export default { CallToAction };
```

### Consuming Dynamic Content in section overrides

To illustrate how to consume Dynamic Content from section overrides, in this example, create a `FixedImageHero` section. First, add the new section to the `cms/faststore/sections.json` file.

```json cms/faststore/sections.json
[
  {
    "name": "FixedImageHero",
    "schema": {
      "title": "Hero with a Fixed Image",
      "description": "Add a quick promotion with an image/action pair",
      "type": "object",
      "required": ["title"],
      "properties": {
        "title": {
          "title": "Title",
          "type": "string"
        },
        "subtitle": {
          "title": "Subtitle",
          "type": "string"
        },
        "link": {
          "title": "Call to Action",
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "title": "Text"
            },
            "url": {
              "type": "string",
              "title": "URL"
            },
            "linkTargetBlank": {
              "type": "boolean",
              "title": "Open link in new window?",
              "default": false
            }
          }
        },
        "colorVariant": {
          "type": "string",
          "title": "Color variant",
          "enumNames": ["Main", "Light", "Accent"],
          "enum": ["main", "light", "accent"]
        },
        "variant": {
          "type": "string",
          "title": "Variant",
          "enumNames": ["Primary", "Secondary"],
          "enum": ["primary", "secondary"]
        }
      }
    }
  }
]
```

Follow the [Creating a new section guide](https://developers.vtex.com/docs/guides/faststore/building-sections-creating-a-new-section) if the intention is to create and customize other sections.

With the section added, run the following command to sync with hCMS:

```bash
yarn cms-sync
```

Remember to add this section to the Landing Page to see the dynamic content

![Landing page sections](https://vtexhelp.vtexassets.com/assets/docs/src/lpsections___8e640c239e0bc198ee6b47479f57c87d.png)

Now, create the Overriden Section following the example below, where a `CustomHeroImage` is created along with the `FixedImageHero`. Once you have the `FixedImageHero` Override Section in the `src/components/sections/FixedImageHero.tsx` file, the `useDynamicContent()` hook is available to retrieve the dynamic content. It's also possible to use the hooks inside custom components, like the `CustomHeroImage` to consume dynamic content, just as in custom sections.

It's also possible to add the data type as generics. In this example, we can use the `ServerDynamicContentQuery` in the case of the API Extension approach shown above.

```tsx src/components/sections/FixedImageHero.tsx
import {
  HeroSection,
  getOverriddenSection,
  useDynamicContent,
} from "@faststore/core";
import { ServerDynamicContentQuery } from "@faststore/core/api";

const OverridenHero = getOverriddenSection({
  Section: HeroSection,
  components: {
    HeroImage: {
      Component: CustomHeroImage,
    },
  },
});

function CustomHeroImage() {
  const context = useDynamicContent<ServerDynamicContentQuery>();
  console.log("ðŸš€ ~ CustomHeroImage context:", context);

  return (
    <img
      src={
        context.data?.extraData?.customFieldFromRoot ??
        "https://via.placeholder.com/350"
      }
      width={400}
      alt={context.data?.extraData?.customField ?? "Hero section image"}
    />
  );
}

export default function FixedImageHero(
  props: React.ComponentProps<typeof OverridenHero>
) {
  const context = useDynamicContent<ServerDynamicContentQuery>();
  console.log("ðŸš€ ~ FixedImageHero context:", context);
  return (
    <OverridenHero
      {...props}
      image={{ src: "noop", alt: "noop" }}
      title={context.data?.extraData?.customField ?? "Hero section title"}
    />
  );
}
```

Remember to import the new Section in the `src/components/index.tsx` file:

```tsx src/components/index.tsx
import FixedImageHero from "./sections/FixedImageHero";

export default { FixedImageHero };
```
